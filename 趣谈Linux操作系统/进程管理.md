# 进程管理


## 进程


1.这里要知道文本文件编译成二进制格式

![](https://static001.geekbang.org/resource/image/85/de/85320245cd80ce61e69c8391958240de.jpeg)

2.这里看例子来了解进程

process.c
```cpp
#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <unistd.h>

extern int create_process (char* program, char** arg_list);

int create_process (char* program, char** arg_list)
{    
    pid_t child_pid;    
    child_pid = fork ();    
    if (child_pid != 0)       
        return child_pid;   
    else {        
        execvp (program, arg_list);        
        abort ();    
    }
}
```

createprocess.c
```
#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <unistd.h>

extern int create_process (char* program, char** arg_list);

int main ()
{
    char* arg_list[] = {
        "ls",
        "-l",
        "/etc/yum.repos.d/",
        NULL
    };
    create_process ("ls", arg_list);
    return 0;
}
```


编译：
```
# 这里的-fPIC是表示创建共享库
[jian@laptop Linux]$ gcc -c -fPIC process.c 
[jian@laptop Linux]$ gcc -c -fPIC createprocess.c 
[jian@laptop Linux]$ ll
total 16
-rw-rw-r-- 1 jian jian  312 Jan 12 08:59 createprocess.c
-rw-rw-r-- 1 jian jian 1696 Jan 12 09:11 createprocess.o
-rw-rw-r-- 1 jian jian  408 Jan 12 08:53 process.c
-rw-rw-r-- 1 jian jian 1576 Jan 12 09:11 process.o

```


3.生成库文件

要想让 create_process 这个函数作为库文件被重用，不能以.o 的形式存在，而是要形成库文件，最简单的类型是静态链接库.a 文件（Archives），仅仅将一系列对象文件（.o）归档为一个文件，使用命令 ar 创建。

```
[jian@laptop Linux]$ ar cr libstaticprocess.a process.o
[jian@laptop Linux]$ ll
total 20
-rw-rw-r-- 1 jian jian  312 Jan 12 08:59 createprocess.c
-rw-rw-r-- 1 jian jian 1728 Jan 12 09:16 libstaticprocess.a
-rw-rw-r-- 1 jian jian  408 Jan 12 08:53 process.c
-rw-rw-r-- 1 jian jian 1576 Jan 12 09:11 process.o

```

4.生成可执行文件
```
[jian@laptop Linux]$ gcc -o staticcreateprocess createprocess.o -L. -lstaticprocess

```

在这个命令里，-L 表示在当前目录下找.a 文件，-lstaticprocess 会自动补全文件名，比如加前缀 lib，后缀.a，变成 libstaticprocess.a，找到这个.a 文件后，将里面的 process.o 取出来，和 createprocess.o 做一个链接，形成二进制执行文件 staticcreateprocess。

5.执行可执行文件

```
[jian@laptop Linux]$ ./staticcreateprocess 
total 68
-rw-r--r--  1 root root  705 Aug 20 01:52 fedora-cisco-openh264.repo
-rw-r--r--. 1 root root 1395 May 16  2019 fedora-modular.repo
...
```

6.动态链接库

静态链接库有一个缺点，就是相同的代码段，如果被多个程序使用的话，在内存里面就有多份，而且一旦静态链接库更新了，如果二进制执行文件不重新编译，也不随着更新。

因而就出现了另一种，动态链接库（Shared Libraries），不仅仅是一组对象文件的简单归档，而是多个对象文件的重新组合，可被多个程序共享。

```
[jian@laptop src]$ gcc -shared -fPIC -o libstaticprocess.so process.o

[jian@laptop src]$ gcc -o dynamiccreateprocess createprocess.o -L. libstaticprocess.so 

```

## 进程树

既然所有的进程都是从父进程 fork 过来的，那总归有一个祖宗进程，这就是咱们系统启动的 init 进程。

```
[jian@laptop src]$ ll /sbin/init 
lrwxrwxrwx 1 root root 22 Sep  3 19:44 /sbin/init -> ../lib/systemd/systemd

```

系统启动之后，init 进程会启动很多的 daemon 进程，为系统运行提供服务，然后就是启动 getty，让用户登录，登录后运行 shell，用户启动的进程都是通过 shell 运行的，从而形成了一棵进程树


通过下面命令看到有几类进程：
```
jian@laptop src]$ ps -ef 
UID        PID  PPID  C STIME TTY          TIME CMD
root         1     0  0 08:45 ?        00:00:05 /usr/lib/systemd/systemd --switched
root         2     0  0 08:45 ?        00:00:00 [kthreadd]
root         3     2  0 08:45 ?        00:00:00 [rcu_gp]
root         4     2  0 08:45 ?        00:00:00 [rcu_par_gp]
root         6     2  0 08:45 ?        00:00:00 [kworker/0:0H-events_highpri]
root         9     2  0 08:45 ?        00:00:00 [mm_percpu_wq]
root        10     2  0 08:45 ?        00:00:00 [ksoftirqd/0]
...
```


你会发现，PID 1 的进程就是我们的 init 进程 systemd，PID 2 的进程是内核线程 kthreadd，这两个我们在内核启动的时候都见过。其中用户态的不带中括号，内核态的带中括号。接下来进程号依次增大，但是你会看所有带中括号的内核态的进程，祖先都是 2 号进程。而用户态的进程，祖先都是 1 号进程。tty 那一列，是问号的，说明不是前台启动的，一般都是后台的服务。


## 总结

![](https://static001.geekbang.org/resource/image/db/a9/dbd8785da6c3ce3fe1abb7bb5934b7a9.jpeg)